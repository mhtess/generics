; example call
;; church -a 'implied_prevalence,most,bare,100,10,3' tfbt_cbg.church

(define args (regexp_split argstring ","))

(define task (first args))
(define quantifier (second args))
(define context (third args))
(define mh_samples (fourth args))
(define mh_burnin (fifth args))
(define factoring_factor (sixth args))

(define tasks '(how-many? true?)) ;; 1-to-1 map between QUD -- task

(define QUD (lambda (task quantifier)
  (case task
    (('implied_prevalence) 'how-many)
    (('truth_conditions) quantifier))))

(define uniform-score (lambda (lowerbound upperbound)
  (- 0 (log (- upperbound lowerbound))))) ;;assuming values are in the range

(define all-true (lambda (lst) (apply and lst)))

(define data-path '/Users/mht/Documents/research/generics/cbg2010-replication/data/)
(define data-file (string-append data-path 'cbgR-exp1_exp3_anonymized-trials.csv))
(define alldata (read-csv data-file))

; (define task 'implied_prevalence)
; (define quantifier 'most)
; (define context 'bare)

(define task? (lambda (x) (equal? (fourth x) task)))
(define quantifier? (lambda (x) (equal? (seventh x) quantifier)))
(define context? (lambda (x) (equal? (fifth x) context)))

(define data-subset (filter 
  (lambda (x) (and (task? x) (quantifier? x) (context? x))) 
  alldata))

(define prevalence-data (map (lambda (x) (last (but-last x))) data-subset))

(define simplified-data
  (map (lambda (x) (string->number x)) prevalence-data))
;  (map (lambda (x) (round (/ (string->number x) 10))) prevalence-data)) ; round for conditioning on discrete data

; (define super-simplified-data
;   (repeat 8 (lambda () (uniform-draw simplified-data))))

;; background
(define (state-prior) (uniform-draw '(0 10 20 30 40 50 60 70 80 90 100)))

(define (all state threshold) (= 100 state))
(define (relaxed-all state threshold) (<= 90 state))

(define (some state some-threshold) (< some-threshold state))
(define (none state threshold) (= 0 state))

(define (most state most-threshold) (< most-threshold state))
(define (anti-most state most-threshold) (>= most-threshold state))

(define (generic state generic-threshold) (< generic-threshold state))
(define (anti-generic state generic-threshold) (>= generic-threshold state))

(define (mu state dummy) true)
(define (how-many state dummy) state)

(define (raise-to-power dist alph)
  (list (first dist) (map (lambda (x) (pow x alph)) (second dist))))

(define (meaning word)
  (case word
        (('all) all)
        (('some) some)
        (('none) none)
        (('most) most)
        (('anti-most) anti-most)
        (('how-many) how-many)
        (('generic) generic)
        (('anti-generic) anti-generic)
        (('mu) mu)))




(define cognitive-model 
  (mem 
  (lambda (generic-theta most-theta some-theta QUD utterance)

  (define (theta-meaning word)
    (case word
        (('most-theta) most-theta)
        (('some-theta) some-theta)
        (('generic-theta) generic-theta)
        (('how-many-theta) 'null)))

  (define (theta words)
    (theta-meaning (string-append words '-theta)))

  (define listener1
    (mem (lambda (words) ;; listener1 doesn't do inference over theta
    (enumeration-query
     (define state (state-prior))
     (define QUD-val ((meaning QUD) state (theta QUD)))

     QUD-val

     (equal? words (apply multinomial (raise-to-power (speaker1 state) alpha)))))))

  (define speaker1
    (mem (lambda (state)
    (enumeration-query
     (define words
      (case QUD
        (('generic)  (uniform-draw (list 'generic 'anti-generic)))
        (('some) (uniform-draw (list 'some 'none)))
        (('most) (uniform-draw (list 'most 'anti-most)))
        (('how-many) (uniform-draw (list 'most 'some 'generic)))))
      (define QUD-val ((meaning QUD) state (theta QUD)))

     words

     (equal? QUD-val
      (apply multinomial (listener0 words)))))))


  (define listener0
    (mem (lambda (words) 
      (enumeration-query
      (define state (state-prior))
      (define QUD-val ((meaning QUD) state (theta QUD)))

      QUD-val

      ((meaning words) state (theta words))))))

  

  (listener1 utterance))))

(define tfbt-model
 ; (lambda (QUD utterance context)
  (lambda (QUD utterance)
    (mh-query 

    (string->number mh_samples)
    (string->number mh_burnin)

    (define query-statement (lambda (utterance)
      (case utterance
          (('most) most-theta)
          (('some) some-theta)
          (('generic) generic-theta))))

    ;(define generic-theta (mem (lambda (context) (uniform-draw '(0 1 2 3 4)))))
     ; (define generic-theta (uniform-draw '(0 1 2 3 4)))
     ; (define some-theta (uniform-draw '(0 1 2 3 4)))
     ; (define most-theta (uniform-draw '(4 5 6 7 8)))

    (define phi (uniform 0 1))

    (define generic-theta (uniform 0 100))
    (define some-theta (uniform 0 100))
    (define most-theta (uniform 0 100))

    (define guessing? (flip phi))

    (define model-predictions
      (cognitive-model generic-theta most-theta some-theta QUD utterance))

    (define L1-distance
     (map 
      (lambda (x) (abs (- x (apply multinomial model-predictions))))
      simplified-data))

    (define factoring
      (factor (- 0 (* (string->number factoring_factor) (sum L1-distance)))))

    (query-statement utterance)
    ;(cognitive-model generic-theta most-theta some-theta QUD utterance)
    ;; if (= QUD truth?) probably will have to pass state into cog-model

    true)))

(define alpha 2)

(define samples (transpose (list (tfbt-model (QUD task quantifier) quantifier))))
(define output-file-name (string-append 'post_ context '_ quantifier '_ task 
  '_mh mh_samples '_ mh_burnin 'L1norm_f factoring_factor 
  '_alpha (number->string alpha) '.csv))
(write-csv samples output-file-name)

(define complete? 'complete)
complete?

;(cognitive-model 3 5 0 'how-many 'most)
;(length simplified-data)
;(length simplified-data)
;super-simplified-data
;; cbg analysis
; (define inner-product (lambda (lst)
;   (sum (map (lambda (x y) (* x y)) (first lst) (second lst)))))

; (define normalize (lambda (lst)
;   (map (lambda (x) (/ x (sum lst))) lst)))

; (define (gen-probs model-preds) 
;   (let ([gen-pos (map (lambda (lst) (position (first lst) utterance)) model-preds)])
;     (map (lambda (y i) (if (< i 0) 0 (list-ref (second y) i))) model-preds gen-pos)))


