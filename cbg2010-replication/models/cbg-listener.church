(define (state-prior) (uniform-draw '(0 1 3 5 7 9 10)))
;(define (state-prior)  ;; rough empirical prior
;  (multinomial '(0 1 3 5 7 9 10) '(7 6 5 4 3 2 1)))

(define (threshold-prior) (uniform-draw '(0 1 3 5 7 9)))
(define (threshold-most-prior) (uniform-draw '(4.9 5)))

(define (all state threshold) (= 10 state))
(define (relaxed-all state threshold) (<= 9 state))
(define (some state threshold) (< 0 state))
(define (none state threshold) (= 0 state))
(define (most state threshold-most) (< threshold-most state))
(define (anti-most state threshold-most) (>= threshold-most state))

(define (generic state threshold) (< threshold state))
(define (anti-generic state threshold) (>= threshold state))

(define (how-many state threshold) state)

(define (raise-to-power dist alph)
  (list (first dist) (map (lambda (x) (pow x alph)) (second dist))))

; pass strings, which then call functions of the same name
(define (meaning word)
  (case word
        (('all) all)
        (('some) some)
        (('none) none)
        (('most) most)
        (('anti-most) anti-most)
        (('how-many) how-many)
        (('generic) generic)
        (('anti-generic) anti-generic)))


(define speaker2
  (mem (lambda (state QUD)
  (enumeration-query
   (define theta (threshold-prior))
   ;(define theta-most (threshold-most-prior))
   (define theta-most 5)
   ;(define QUD (if (flip) 'some 'state))
   (define words (uniform-draw (list 'generic 'anti-generic)))
;;   (define words (uniform-draw (list 'some 'none)))
;;    (define words (uniform-draw (list 'most 'anti-most)))
;;   (define words (uniform-draw (list 'generic 'some 'most 'all)))
   (define QUD-val ((meaning QUD) state theta))

   words

   (equal? QUD-val
  ;;  (apply multinomial (listener1 words theta theta-most QUD)) ;; listener1 doesn't do inference over theta
    (apply multinomial (listener1 words QUD)) ;; listener1 does inference over theta
    )))))

(define listener1
  (mem (lambda (words QUD) ;; listener1 does inference over theta
 ;; (mem (lambda (words theta theta-most QUD) ;; listener1 doesn't do inference over theta
  (enumeration-query
   (define theta (threshold-prior))
   ;(define theta-most (threshold-most-prior))
   (define theta-most 5)
   (define state (state-prior))
   (define QUD-val ((meaning QUD) state theta))
   
   QUD-val

   (equal? words (apply multinomial (speaker1-knowsTheta state theta theta-most QUD)))))))

(define speaker1-knowsTheta
 ;; (mem (lambda (state QUD) ;; speaker1 does inference over theta
  (mem (lambda (state theta theta-most QUD) ;; speaker1 doesn't do inference over theta
  (enumeration-query
   (define theta (threshold-prior))
   ;(define theta-most (threshold-most-prior))
   (define theta-most 5)
   ;(define QUD (if (flip) 'some 'state))
   ;;(define words (uniform-draw (list 'generic 'anti-generic)))
   ;;(define words (uniform-draw (list 'most 'anti-most)))
   ;;(define words (uniform-draw (list 'some 'none)))
   (define words (uniform-draw (list 'generic 'some 'most)))
   (define QUD-val ((meaning QUD) state theta))

   words

   (equal? QUD-val
    (apply multinomial (raise-to-power (listener0 words theta theta-most QUD) alpha)))))))


(define speaker1
  (mem (lambda (state QUD) ;; speaker1 does inference over theta
  ;;(mem (lambda (state theta theta-most QUD) ;; speaker1 doesn't do inference over theta
  (enumeration-query
   (define theta (threshold-prior))
   ;(define theta-most (threshold-most-prior))
   (define theta-most 5)
   ;(define QUD (if (flip) 'some 'state))
   (define words
    (case QUD
      (('generic)  (uniform-draw (list 'generic 'anti-generic)))
      (('some) (uniform-draw (list 'some 'none)))
      (('most) (uniform-draw (list 'most 'anti-most)))
      (('how-many) (uniform-draw (list 'generic 'some 'most)))))

   (define QUD-val ((meaning QUD) state theta))

   words

   (equal? QUD-val
    (apply multinomial (raise-to-power (listener0 words theta theta-most QUD) alpha)))))))

(define listener0
  (mem (lambda (words theta theta-most QUD) 
    (enumeration-query
    (define state (state-prior))
    (define QUD-val ((meaning QUD) state theta))

    QUD-val

    ;(if (flip 0.95)
    (if (equal? words 'most)
      ((meaning words) state theta-most)
      ((meaning words) state theta))
     ; true)
    ))))


(define alpha 100)
;;(map (lambda (x) (listener1 x 'how-many)) (list 'some 'most 'generic))

;(map (lambda (x) (listener1 x 'how-many)) (list 'generic 'some 'most))
;(speaker1 7 3 5 'how-many)
;(listener0 'most 3 5 'how-many)

(define utterance 'most)

(define l1 (listener1 utterance 'how-many))
(define s1 (map (lambda (x) (speaker1 x utterance)) '(1 3 5 7 9 10)))
(define s2 (map (lambda (x) (speaker2 x utterance)) '(1 3 5 7 9 10)))

(define inner-product (lambda (lst)
  (sum (map (lambda (x y) (* x y)) (first lst) (second lst)))))

(define normalize (lambda (lst)
  (map (lambda (x) (/ x (sum lst))) lst)))

; (define (gen-pos model-preds) (map (lambda (lst) (position (first lst) utterance)) s1))
(define (gen-probs model-preds) 
  (let ([gen-pos (map (lambda (lst) (position (first lst) utterance)) model-preds)])
    (map (lambda (y i) (list-ref (second y) i)) model-preds gen-pos)))

;s1
(list (inner-product l1)
     (inner-product (list (normalize (gen-probs s1)) '(1 3 5 7 9 10))))

;(map (lambda (x) (speaker1 x 'how-many)) '(1 3 5 7 9 10))
;(map (lambda (x) (speaker1 x 'some)) '(1 3 5 7 9 10))
;(map (lambda (x) (speaker1 x 'how-many)) '(1 3 5 7 9 10))

;(map (lambda (x) (speaker2 x 'generic)) '(1 3 5 7 9 10))


