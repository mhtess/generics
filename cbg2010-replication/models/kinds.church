(define pr-kind-given-property ;; probability of a kind given observing the property
    (lambda (prevalence distinctive)
  (enumeration-query

    (define other-kind-prevalence ;(uniform-draw '(0.1 0.3 0.5 0.7 0.9)))
            (if distinctive 0.1 0.5))

    (define observe-property 
        (lambda (prevalence kind)
        (or (and (equal? kind 'morseth) (flip prevalence))
            (and (equal? kind 'other) (flip other-kind-prevalence)))))
    (define kind (uniform-draw '(morseth other)))

    (equal? kind 'morseth)
   
    (observe-property prevalence kind)))) ;; prevalence % of kind have property

(define get-true-prob (lambda (lst)
    (list-ref (second lst) (position (first lst) #t))))

(define generic? (lambda (property-predictive-power threshold) (> property-predictive-power threshold)))
(define no-generic? (lambda (property-predictive-power threshold) (<= property-predictive-power threshold)))
(define morseth? (lambda (state theta) (flip state)))
(define not-morseth? (lambda (state theta) (not (flip state))))

(define meaning (lambda (word)
    (case word
        (('yes) generic?)
        (('no) no-generic?)
        (('morseth) morseth?)
        (('not-a-morseth) not-morseth?))))

(define (state-prior) (uniform-draw '(0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1)))

(define listener0-of-kinds
    (mem (lambda (words theta QUD)
        (enumeration-query
            (define state (state-prior))

            (define (QUDval QUD)
                (case QUD
                    (('is-morseth) ((meaning words) state theta))
                    (('who-is-it) (flip state))))
        
            QUDval

            ((meaning words) state theta)))))


(define speaker1-of-kinds
;    (mem (lambda (prevalence distinctive)
    (mem (lambda (prevalence distinctive)
    (enumeration-query 
        ;(define theta (uniform-draw '(0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9)));; threshold for claiming the generic to be true
        ;; doesn't operate over prevalence but predictive power
        (define theta 0.1)

        (define state (get-true-prob (pr-kind-given-property prevalence distinctive))) 

        (define QUD (uniform-draw (list 'is-morseth 'who-is-it)))

        
        (define words (uniform-draw '(yes no)))

        (define (QUDval QUD)
            (case QUD
                (('is-morseth) ((meaning words) state theta))
                (('who-is-it) (flip state))))

        words

        true))))
        ; (and (QUDval QUD) (equal? QUD 'who-is-it))
        ; ))))
          ; (equal? QUD-val
          ;    (apply multinomial (listener0-of-kinds words theta QUD)))))))


(define listener1
  (mem (lambda (words QUD) ;; listener1 does inference over theta
  (enumeration-query
   (define theta (uniform-draw '(0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9)))
   ;(define theta-most (threshold-most-prior))
   (define prevalence (state-prior))
   (define state (get-true-prob (pr-kind-given-property prevalence distinctive))) 
   (define QUD-val ((meaning words) state theta))

  state

   (equal? words 
    (apply multinomial (raise-to-power (speaker1-of-kinds state theta) alpha)))))))



;(kind-given-property kind prevalence property)

(speaker1-of-kinds 0.3 #t)

; (define get-yes-prob (lambda (lst)
;     (list-ref (second lst) (position (first lst) 'yes))))

;     ;(map (lambda (x) (get-true-prob (kind-given-property 'morseth x 'si))) (list 0.1 0.3 0.5 0.7 0.9))
; ;(map (lambda (x y) (get-yes-prob (speaker1-of-kinds x y))) (list 0.1 0.3 0.5 0.7 0.9) (list #t #t #t #t #t))

; (map (lambda (x y) (get-yes-prob (speaker1-of-kinds x y))) 
;     (list 0.1 0.3 0.5 0.7 0.9) (list #f #f #f #f #f))

;(map speaker1-of-kinds (list 0.1 0.3 0.5 0.7 0.9) (list #f #f #f #f #f))


